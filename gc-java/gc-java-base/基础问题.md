## volatile的理解？
特性1：内存可见性，缓存一致性协议（底层会锁内存行）来保证每个线程中的缓存信息是一致的。

特性2：有序性（指令重新排序，JVM在保证单线程下不会出现问题的情况下，会优化指令的执行顺序。比如创建一个对象（1.开辟内存空间，2.初始化，3.指向内存地址），可以先指向内存地址再初始化）。

##  for(;;) 和 while(true)的区别？
  推荐使用for(;;)， 因为通过汇编指令可以很明显的看出区别for(;;)是一条指令，while(true)是4条指令。
  
## 如何实现一个独占锁？
第一步通过CAS判断是否存在锁，不存在返回ture,存在将新的线程加入队列中并且设置park 等待。

第二步当占用资源的锁使用完成，需要通过队列里面的线程进行unpark操作去执行。

## 不同的类加载器加载相同的类，相等吗，为什么？
答：不相等，因为不同加载器加载类后存放的地方是隔离的，虽然都在方法区。举例就像存在在两个list 集合一样的道理。

## Jvm 中存在哪些常量池？
1. class中的常量池：class文件中的，类名，方法名，字段等一些信息。

2. 动态常量池：Java对象中的常量池信息，载入常量池，存储在元空间（方法区）。

3. 字符串常量池：存放字符串的，在堆区。

## this指针是何时被赋值的？
答：执行引擎在执行带有操作数的字节码指令时，会有一个构造运行环境的过程。this指针就是在构造运行环境过程中实现的。不完全对象会被复制一份，这一份就是用于被this指向。

## 创建的对象是否只会存在堆区，为什么？
不是，存在栈上分配的情况。 Jvm在逃逸分析开启的情况，存在连续创建对象的时候，会有对象不创建在堆区，会创建到虚拟栈上。

## Java堆内存最大允许多少，为什么？
开启指针压缩的情况下：32G。

原因：对象头中的类型指针指向的就是对象引用变量在方法区的地址，通过这个地址可以找到整个对象的全部内容在内存中位置。

类型指针在开启指针压缩的情况下，占用4个字节即32位，2的32次方就是4G，类型指针最大可以存在4G内存的位置。 又因为每个对象在开启指针压缩的情况下，最后3位000会被去掉。 所以实际4个字节可以表示 2的35次方-2的3次方的最大内存地址，即32G内存的最大位置。

因为现在都是64位机器了，那么如果电脑或者服务器的内存超过32G内存，在开启指针压缩的情况下就是出现找不到内存地址情况。

如果在开启指针压缩下优化这个问题，可以将Java对象的8字节对齐改成16字节对其，甚至32字节对其。这个能表示的内存最大值就是64G，128G了。
