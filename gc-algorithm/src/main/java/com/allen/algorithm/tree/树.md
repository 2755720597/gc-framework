## 二叉树最大深度
**方法1：递归算法**

* 原理：每一颗树的最大深度都是左右子树中的最大深度再加1
* 优点：代码行数非常少，易读性强
* 缺点：每一次递归调用增加额外的函数调用，新增栈帧空间，易造成stackoverflow的错误，效率低

**方法2：深度优先（DFS）或广度优先（BFS），遍历二叉树，同时求得最大深度**

* 深度优先遍历（DFS）：利用栈（先进后出）。对每一个可能的分支路径深入到不能再深入为止，而且每个结点只能访问一次。要特别注意的是，二叉树的深度优先遍历比较特殊，可以细分为先序遍历（根-左-右）、中序遍历（左-根-右）、后序遍历（左-右-根）。具体说明如下：
  
  
      1、对于每个节点来说，先遍历当前节点，然后把右节点压栈，再压左节点（这样弹栈的时候会先拿到左节点遍历，符合深度优先遍历要求）
      2、弹栈，拿到栈顶的节点，如果节点不为空，重复步骤 1， 如果为空，结束遍历。
  
  ![](https://images2018.cnblogs.com/blog/737444/201803/737444-20180308163227000-929643824.png)
  
  先序遍历：对任一子树，先访问根，然后遍历其左子树，最后遍历其右子树。根结点 ---> 左子树 ---> 右子树 .如 1 2 4 5 7 8 3 6
  
  中序遍历：对任一子树，先遍历其左子树，然后访问根，最后遍历其右子树。左子树---> 根结点 ---> 右子树 .如 4 2 7 5 8 1 3 6
  
  后序遍历：对任一子树，先遍历其左子树，然后遍历其右子树，最后访问根。左子树 ---> 右子树 ---> 根结点 .如 4 7 8 5 2 6 3 1
  
  层次遍历：只需按层次遍历即可 .如 1 2 3 4 5 6 7 8


    先序遍历：在第一次遍历到节点时就执行操作，一般只是想遍历执行操作（或输出结果）可选用先序遍历；
    中序遍历：对于二分搜索树，中序遍历的操作顺序（或输出结果顺序）是符合从小到大（或从大到小）顺序的，故要遍历输出排序好的结果需要使用中序遍历
    后序遍历：后续遍历的特点是执行操作时，肯定已经遍历过该节点的左右子节点，故适用于要进行破坏性操作的情况，比如删除所有节点
   

* 广度优先遍历（BFS）：利用队列，逐层遍历

    广度优先遍历，指的是从图的一个未遍历的节点出发，先遍历这个节点的相邻节点，再依次遍历每个相邻节点的相邻节点。
    
## 二叉搜索树（BST）
  对于任意一个节点，我们不光需要左节点值小于该节点，并且左子树上的所有节点值都需要小于该节点。（右节点一致）所以我们在此引入上界与下界，用以保存之前的节点中出现的最大值与最小值。

  * 若它的左子树不为空，则所有左子树上的值均小于其根节点的值
  * 若它的右子树不为空，则所有右子树上的值均大于其根节点得值
  * 它的左右子树也分别为二叉搜索树
  
  ![](https://www.geekxh.com/assets/img/1.03e01a60.jpg)
  
  * 如果val小于当前结点的值，转向其左子树继续搜索；
  * 如果val大于当前结点的值，转向其右子树继续搜索；
  * 如果已找到，则返回当前结点。
  
  ![](https://www.geekxh.com/assets/img/2.92dd024b.jpg)
  
  
  
  



