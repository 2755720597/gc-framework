## 一、熔断器具体又是怎么工作的呢
![](https://img-blog.csdnimg.cn/2018112609062481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZzeTk1OTU4ODc=,size_16,color_FFFFFF,t_70)

主要在三种状态中转换：

* 关闭状态 ：

当熔断器处于关闭状态时，请求是可以被放行的；
  
当熔断器统计的失败次数触发开关时，转为打开状态。
  
* 打开状态 ：

当熔断器处于打开状态时，所有请求都是不被放行的，直接返回失败；
  
只有在经过一个设定的时间窗口周期后，熔断器才会转换到半开状态
  
* 半开状态 ：

当熔断器处于半开状态时，当前只能有一个请求被放行；
  
这个被放行的请求获得远端服务的响应后，假如是成功的，熔断器转换为关闭状态，否则转换到打开状态。

     既是高峰期的时候关闭某些复杂的操作--》降级；

## 二.熔断
当下游的服务因为某种原因突然变得**不可用或响应过慢**，上游服务为了保证自己整体服务的可用性，不再继续调用目标服务，直接返回，快速释放资源。如果目标服务情况好转则恢复调用。

需要说明的是熔断其实是一个框架级的处理，那么这套熔断机制的设计，基本上业内用的是断路器模式，如Martin Fowler提供的状态转换图如下所示

![](https://www.pianshen.com/images/850/bb730fd5f5da3ca4659c84802660f84a.JPEG)

* 最开始处于closed状态，一旦检测到错误到达一定阈值，便转为open状态；
* 这时候会有个 reset timeout，到了这个时间了，会转移到half open状态；
* 尝试放行一部分请求到后端，一旦检测成功便回归到closed状态，即恢复服务；

## 三.降级
关于降级,这里有两种场景:

* 当下游的服务因为某种原因响应过慢，下游服务主动停掉一些不太重要的业务，释放出服务器资源，增加响应速度！
* 当下游的服务因为某种原因不可用，上游主动调用本地的一些降级逻辑，避免卡顿，迅速返回给用户！

其实乍看之下，很多人还是不懂熔断和降级的区别!

其实应该要这么理解:

* 服务降级有很多种降级方式！如开关降级、限流降级、熔断降级!
* 服务熔断属于降级方式的一种！

可能有的人不服，觉得熔断是熔断、降级是降级，分明是两回事啊！其实不然，因为从实现上来说，熔断和降级必定是一起出现。因为当发生**下游服务不可用**的情况，
这个时候为了对最终用户负责，就需要**进入上游的降级逻辑**了。因此，将熔断降级视为降级方式的一种，也是可以说的通的！

## 四.熔断和降级的互相交集
4.1 类似性
* 1 、目的很一致，都是从可用性可靠性着想，为防止系统的整体缓慢甚至崩溃，采用的技术手段；
* 2、最终表现类似，对于两者来说，最终让用户体验到的是某些功能暂时不可达或不可用；
* 3、粒度一般都是服务级别，当然，业界也有不少更细粒度的做法，比如做到数据持久层（允许查询，不允许增删改）；
* 4、自治性要求很高，熔断模式一般都是服务基于策略的自动触发，降级虽说可人工干预，但在微服务架构下，完全靠人显然不可能，开关预置、配置中心都是必要手段；

4.2 区别

* 触发原因不太一样，服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑；
* 管理目标的层次不太一样，熔断其实是一个框架级的处理，每个微服务都需要（无层级之分），而降级一般需要对业务有层级之分（比如降级一般是从最外围服务开始）
* 实现方式不太一样




