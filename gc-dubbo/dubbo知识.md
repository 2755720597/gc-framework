## 1. Dubbo的服务请求失败怎么处理
dubbo启动时默认有**重试机制和超时机制。**

超时机制的规则是如果在一定的时间内，provider没有返回，则认为本次调用失败，

重试机制在出现调用失败时，会再次调用。如果在配置的调用次数内都失败，则认为此次请求异常，抛出异常。

根据业务特点，做降级及熔断处理。

## 2. dubbo的负载均衡有几种算法?
**Random LoadBalance(随机均衡算法)**

* 随机，按权重设置随机概率。
* 在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。

优点：设置了provider的权重比例，使性能高的provider多承担负载，相较于轮询算法更加平均。

缺点：provider性能比例需要人为设定，不会根据每个provider的实时表现进行调节。

**RoundRobin LoadBalance(权重轮循均衡算法)**

* 轮循，按公约后的权重设置轮循比率。
* 存在慢的提供者累积请求问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。(针对此种情况，需要降低该服务的权值，以减少对其调用)

优点：考虑了每个provider的性能，使性能高的provider多承担负载，简洁高效。

缺点：（1）provider性能比例需要人为设定，不会根据每个provider的实时表现进行调节。

(2）当某一台个provider很慢但没有挂，服务分配到那里就会卡住等待，导致所有请求分配卡在该个provider上。

**LeastAction LoadBalance(最少活跃调用数均衡算法)**

* 最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。
* 使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。

  优点：可以根据provider实时运行情况动态地调节，适合所有provider性能都差不多的情况。

  缺点：对于各provider性能差别较大的情况，（如本次比赛，性能1:2:3），性能最差的provider往往活跃数最小，会将较多的请求发送到small服务器上。

**ConsistentHash LoadBalance(一致性Hash均衡算法)**

* 一致性Hash，相同参数的请求总是发到同一提供者。
* 当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。


优点：可以尽量地减少服务器挂掉、增加所带来的影响，对于带有图片、视频类的缓冲型服务请求非常适合。

缺点： （仅限于对本题目）对于题目中不同负载能力的provider没有有效的比例均衡能力。

[一致hash算法](https://blog.csdn.net/piqianming/article/details/79670051)

https://blog.csdn.net/gongxing12/article/details/96613486

## 在 Provider 上可以配置的 Consumer 端的属性有哪些？
1）timeout：方法调用超时 

2）retries：失败重试次数，默认重试 2 次 

3）loadbalance：负载均衡算法，默认随机 

4）actives 消费者端，最大并发调用限制

## Dubbo如何一条链接并发多个调用
* Dubbo协议在客户端针对所有的Service类，默认是使用单一Netty长连接来处理对这些Service类的方法的RPC调用请求的，即所有Service共享这个单一netty长连接。而在客户端，如在web环境中，任何一个时刻，可能存在多个线程并发对该Service进行并发调用，这些请求都是通过该单一Channel发送和获取结果的，而Netty所有请求都是异步，故dubbo如何保证这些并发线程能正确获取到自己的请求结果，而不会造成数据混乱呢？核心实现为：

* 客户端Request通过AtomicLong生成的当前进程全局唯一id，服务端响应回传该id；
  
* 客户端通过FUTURES静态ConcurrentHashMap保存调用id和异步结果DefaultFuture之间的关系，服务端响应时，查询根据Response的回传请求id，获取该response对应的DefaultFuture，通过await和signal机制实现请求发起线程和结果获取线程之间的通信，最终请求发起线程得到最终的结果。

https://my.oschina.net/u/3159571/blog/3019453

## Dubbo 的使用场景有哪些？
* 1.RPC分布式服务

透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。

当网站变大后，不可避免的需要拆分应用进行服务化，以提高开发效率，调优性能，节省关键竞争资源等。

比如：为了适用不断变化的市场需求，以及多个垂直应用之间数据交互方便，我们把公共的业务抽取出来作为独立的模块，为其他的应用提供服务，系统逐渐依赖于抽象和rpc远程服务调用。

* 2.配置管理

软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。

当服务越来越多时，服务的URL地址信息就会爆炸式增长，配置管理变得非常困难，F5硬件负载均衡器的单点压力也越来越大。

* 3.服务依赖

服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。

当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。

* 4.服务扩容

接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？等等……

## Dubbo 的核心功能？
(1) Remoting：网络通信框架，提供对多种 NIO 框架抽象封装，包括“同步转异步”和“请求-响应”模式的信息交换方式。

(2) Cluster：服务框架，提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。

(3)Registry：服务注册，基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。

## Dubbo 服务器注册与发现的流程？
**服务容器Container** 负责启动，加载，运行服务提供者。

**服务提供者Provider**在启动时，向注册中心注册自己提供的服务。

**服务消费者Consumer**在启动时，向注册中心订阅自己所需的服务。

**注册中心Registry**返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。

**服务消费者Consumer**，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。

**服务消费者Consumer和提供者Provider**，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心Monitor。

##  Dubbo 的注册中心集群挂掉，发布者和订阅者之间还能通信么？
1、【提供者】在【启动】时，向注册中心zk 【注册】自己提供的服务。
2、【消费者】在【启动】时，向注册中心zk 【订阅】自己所需的服务。

可以的，消费者在启动时，消费者会从zk拉取注册的生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用。

消费者本地有一个生产者的列表，他会按照列表继续工作，倒是无法从注册中心去同步最新的服务列表，短期的注册中心挂掉是不要紧的，但一定要尽快修复。

挂掉是不要紧的，但前提是你没有增加新的服务，如果你要调用新的服务，则是不能办到的

**健状性**

* 监控中心宕掉不影响使用，只是丢失部分采样数据
* 数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务
* 注册中心对等集群，任意一台宕掉后，将自动切换到另一台
* 注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯
* 服务提供者无状态，任意一台宕掉后，不影响使用
* 服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复

## Dubbo源码使用了哪些设计模式
![](https://img-blog.csdnimg.cn/20210102125849394.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvc2hpeHV5ZQ==,size_16,color_FFFFFF,t_70)

**工厂模式**

Provider 在 export 服务时，会调用 ServiceConfig 的 export 方法。ServiceConfig 中有个字段：

private static final Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();

Dubbo 里有很多这种代码。这也是一种工厂模式，只是实现类的获取采用了 JDK SPI 的机制。这么实现的优点是可扩展性强，想要扩展实现，只需要在 classpath
下增加个文件就可以了，代码零侵入。另外，像上面的 Adaptive 实现，可以做到 调用时动态决定调用哪个实现，但是由于这种实现采用了动态代理，会造成代码 调试比较麻烦，需要分析出实际调用的实现类。

**装饰器模式**

Dubbo 在启动和调用阶段都大量使用了装饰器模式。以 Provider 提供的调用链为 例，具体的调用链代码是在 ProtocolFilterWrapper 的 buildInvokerChain 完成
的，具体是将注解中含有 group=provider 的 Filter 实现，按照 order 排序，最 后的调用顺序是：

EchoFilter -> ClassLoaderFilter -> GenericFilter -> ContextFilter ->
ExecuteLimitFilter -> TraceFilter -> TimeoutFilter -> MonitorFilter ->
ExceptionFilter

更确切地说，这里是装饰器和责任链模式的混合使用。例如，EchoFilter 的作用是 判断是否是回声测试请求，是的话直接返回内容，这是一种责任链的体现。而像
ClassLoaderFilter 则只是在主功能上添加了功能，更改当前线程的 ClassLoader， 这是典型的装饰器模式。

**观察者模式**

Dubbo 的 Provider 启动时，需要与注册中心交互，先注册自己的服务，再订阅自己的服务，订阅时，采用了观察者模式，开启一个 listener。注册中心会每 5 秒定
时检查是否有服务更新，如果有更新，向该服务的提供者发送一个 notify 消息，provider 接受到 notify 消息后，即运行 NotifyListener 的 notify 方法，执行监听器方法。

**动态代理模式**

Dubbo 扩展 JDK SPI 的类 ExtensionLoader 的 Adaptive 实现是典型的动态代理实现。Dubbo 需要灵活地控制实现类，即在调用阶段动态地根据参数决定调用哪
个实现类，所以采用先生成代理类的方法，能够做到灵活的调用。生成代理类的代码是 ExtensionLoader 的 createAdaptiveExtensionClassCode 方法。代理类的主要逻辑是，获取 URL 参数中指定参数的值作为获取实现类的 key。

## Dubbo集群提供了哪些负载均衡策略？
* Random LoadBalance：随机选取提供者策略，随机转发请求，可以加权
* RoundRobin LoadBalance：轮循选取提供者策略，请求平均分布
* LeastActive LoadBalance：最少活跃调用策略，可以让慢提供者接收更少的请求
* ConstantHash LoadBalance：一致性 Hash 策略，相同参数请求总是发到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者

