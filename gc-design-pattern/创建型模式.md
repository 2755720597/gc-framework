## 创建型模式
  在软件工程中，创建型模式是**处理对象创建**的设计模式，试图根据实际情况使用合适的方式创建对象。基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。

  创建型模式由两个主导思想构成。**一是将系统使用的具体类封装起来，二是隐藏这些具体类的实例创建和结合的方式**。

  创建型模式又分为**对象创建型模式和类创建型模式**。对象创建型模式处理对象的创建，类创建型模式处理类的创建。详细地说，对象创建型模式把对象创建的一部分推迟到另一个对象中，而类创建型模式将它对象的创建推迟到子类中。
  
## 1、抽象工厂模式(Abstract Factory)
   **所谓抽象工厂模式就是她提供一个接口，用于创建相关或者依赖对象的家族，而不需要明确指定具体类。** 他允许客户端使用抽象的接口来创建一组相关的产品，而不需要关系实际产出的具体产品是什么。
   这样一来，客户就可以从具体的产品中被解耦。**它的优点是隔离了具体类的生成**，使得客户端不需要知道什么被创建了，**而缺点就在于新增新的行为会比较麻烦**，因为当添加一个新的产品对象时，
   需要更加需要更改接口及其下所有子类。其UML结构图如下：
   
   ![](https://images0.cnblogs.com/blog/381060/201310/08191340-e13eefcde4ee4e029ee5df41067866dd.png)
   
   参与者：
   
        AbstractFactory：抽象工厂。抽象工厂定义了一个接口，所有的具体工厂都必须实现此接口，这个接口包含了一组方法用来生产产品。

        ConcreteFactory：具体工厂。具体工厂是用于生产不同产品族。要创建一个产品，客户只需要使用其中一个工厂完全不需要实例化任何产品对象。

        AbstractProduct：抽象产品。这是一个产品家族，每一个具体工厂都能够生产一整组产品。

        Product：具体产品。
   
## 2、建造者模式(Builder)
   **对于建造者模式而已，它主要是将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示**。适用于那些产品对象的内部结构比较复杂。
   
   建造者模式将复杂产品的构建过程封装分解在不同的方法中，使得创建过程非常清晰，能够让我们更加精确的控制复杂产品对象的创建过程，同时它隔离了复杂产品对象的创建和使用，
   使得相同的创建过程能够创建不同的产品。但是如果某个产品的内部结构过于复杂，将会导致整个系统变得非常庞大，不利于控制，同时若几个产品之间存在较大的差异，则不适用建造者模式，
   毕竟这个世界上存在相同点大的两个产品并不是很多，所以它的使用范围有限。其UML结构图：
        
   ![](https://images0.cnblogs.com/blog/381060/201310/08191342-1fb6ec5ff4734e7baaa87bb950cd8385.jpg)
   
   参与者：
   
    Builder：抽象建造者。它声明为创建一个Product对象的各个部件指定的抽象接口。
    ConcreteBuilder：具体建造者。实现抽象接口，构建和装配各个部件。
    Director：指挥者。构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象，它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。
    Product：产品角色。一个具体的产品对象。
   
## 3、工厂方法模式(Factory Method)
   作为抽象工厂模式的孪生兄弟，**工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，也就是说工厂方法模式让实例化推迟到子类。**
   
   工厂方法模式非常符合“开闭原则”，当需要增加一个新的产品时，我们只需要增加一个具体的产品类和与之对应的具体工厂即可，无须修改原有系统。
   同时在工厂方法模式中用户只需要知道生产产品的具体工厂即可，无须关系产品的创建过程，甚至连具体的产品类名称都不需要知道。虽然他很好的符合了“开闭原则”，
   但是由于每新增一个新产品时就需要增加两个类，这样势必会导致系统的复杂度增加。其UML结构图：
   
   ![](https://images0.cnblogs.com/blog/381060/201310/08191345-b284145d01324a29a331abbe0285df33.png)
   
   参与者：
   
     Product：抽象产品。所有的产品必须实现这个共同的接口，这样一来，使用这些产品的类既可以引用这个接口。而不是具体类 。

    ConcreteProduct：具体产品。

    Creator：抽象工厂。它实现了所有操纵产品的方法，但不实现工厂方法。Creator所有的子类都必须要实现factoryMethod()方法。

    ConcreteCreator：具体工厂。制造产品的实际工厂。它负责创建一个或者多个具体产品，只有ConcreteCreator类知道如何创建这些产品。
    
## 4、原型模式(Prototype)
  在我们应用程序可能有某些对象的结构比较复杂，但是我们又需要频繁的使用它们，如果这个时候我们来不断的新建这个对象势必会大大损耗系统内存的，
  这个时候我们需要使用原型模式来对这个结构复杂又要频繁使用的对象进行克隆。所以**原型模式就是用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。**
  
  它主要应用与那些创建新对象的成本过大时。它的主要**优点就是简化了新对象的创建过程，提高了效率，同时原型模式提供了简化的创建结构**。UML结构图：
  
  ![](https://images0.cnblogs.com/blog/381060/201310/08191348-8b491c9385b74afdb614f75f1cced48d.png)
  
  参与者：
  
    Prototype：抽象原型类。声明克隆自身的接口。
    ConcretePrototype：具体原型类。实现克隆的具体操作。
    Client：客户类。让一个原型克隆自身，从而获得一个新的对象。
    
    
## 5、单例模式(Singleton)
  单例模式，从字面上看就是一个实例的意思。所以它的定义就是**确保某一个类只有一个实例，并且提供一个全局访问点**。
  
  单例模式具备如下几个特点：

    1、只有一个实例。
    2、能够自我实例化。
    3、提供全局访问点。

  所以说当系统中只需要一个实例对象或者系统中只允许一个公共访问点，除了这个公共访问点外，不能通过其他访问点访问该实例时，可以使用单例模式。

  单例模式的**主要优点就是节约系统资源、提高了系统效率，同时也能够严格控制客户对它的访问**。也许就是因为系统中只有一个实例，这样就导致了单例类的职责过重，违背了“单一职责原则”，
  同时也没有抽象类，所以扩展起来有一定的困难。其UML结构图非常简单，就只有一个类：
  
  ![](https://images0.cnblogs.com/blog/381060/201310/08191350-7ffc1abdcf934de1abd3f7dcc683d992.png)
  
   参与者：
  
     Singleton：单例。
           
   
         
   