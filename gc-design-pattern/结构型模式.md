## 结构型模式
   结构型模式主要是**用于处理类或者对象的组合，它描述了如何来类或者对象更好的组合起来，是从程序的结构上来解决模块之间的耦合问题**。它主要包括适配器模式、桥接模式、
   组合模式、装饰模式、外观模式、享元模式、代理模式这个七个模式。
   
## 1、适配器模式(Adapter)
   在我们的应用程序中我们可能需要将两个不同接口的类来进行通信，在不修改这两个的前提下我们可能会需要某个中间件来完成这个衔接的过程。这个中间件就是适配器。
   所谓**适配器模式就是将一个类的接口，转换成客户期望的另一个接口**。它可以让原本两个不兼容的接口能够无缝完成对接。
  
   作为中间件的适配器将目标类和适配者解耦，增加了类的透明性和可复用性。
   
   ![](https://images0.cnblogs.com/blog/381060/201310/08191354-cb2bd51f8967493b95e23a2e7f33c2bb.png)
   
   参与者：
   
        Target：目标抽象类 。

        Adapter：适配器类 。通过在内部包装一个Adaptee，将源接口转成目标接口。

        Adaptee：适配者类 。需要适配的类。

        Client：客户类。
        
## 2、桥接模式(Bridge)
  如果说某个系统能够从多个角度来进行分类，且每一种分类都可能会变化，那么我们需要做的就是讲这多个角度分离出来，使得他们能独立变化，减少他们之间的耦合，
  这个分离过程就使用了桥接模式。所谓**桥接模式就是将抽象部分和实现部分隔离开来，使得他们能够独立变化。**
  
  桥接模式将**继承关系转化成关联关系，封装了变化，完成了解耦，减少了系统中类的数量，也减少了代码量。**
  
  ![](https://images0.cnblogs.com/blog/381060/201310/08191402-75372ce155e8428bafa2efc0271404e4.png)
  
  参与者

    Abstraction：抽象类。
    RefinedAbstraction：扩充抽象类。
    Implementor：实现类接口。
    ConcreteImplementor：具体实现类 。        
    
## 3、组合模式(Composite)
 组合模式组合多个对象形成树形结构以表示“整体-部分”的结构层次。**它定义了如何将容器对象和叶子对象进行递归组合，使得客户在使用的过程中无须进行区分，可以对他们进行一致的处理。**

 在使用组合模式中需要注意一点也是组合模式最关键的地方：**叶子对象和组合对象实现相同的接口**。这就是组合模式能够将叶子节点和对象节点进行一致处理的原因。

 虽然组合模式能够清晰地定义分层次的复杂对象，也使得增加新构件也更容易，但是这样就导致了系统的设计变得更加抽象，如果系统的业务规则比较复杂的话，使用组合模式就有一定的挑战了。
 
 ![](https://images0.cnblogs.com/blog/381060/201310/08191402-304eb9222e934734a9bf8ce2a85fbe0c.jpg)
 
  参与者：

      Component ：组合中的对象声明接口，在适当的情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component子部件。
      Leaf：叶子对象。叶子结点没有子结点。
      Composite：容器对象，定义有枝节点行为，用来存储子部件，在Component接口中实现与子部件有关操作，如增加(add)和删除(remove)等。
      
## 4、装饰者模式(Decorator)
  我们可以通过继承和组合的方式来给一个对象添加行为，虽然使用继承能够很好拥有父类的行为，但是它存在几个缺陷：**一、对象之间的关系复杂的话，系统变得复杂不利于维护。二、容易产生“类爆炸”现象。三、是静态的。**
  在这里我们可以通过使用装饰者模式来解决这个问题。

  装饰者模式，**动态地将责任附加到对象上。**若要扩展功能，装饰者提供了比继承更加有弹性的替代方案。虽然装饰者模式能够动态将责任附加到对象上，但是他会产生许多的细小对象，增加了系统的复杂度。
  
  ![](https://images0.cnblogs.com/blog/381060/201310/08191404-6db8b93b3bca47c9b58df0675ebff352.png)
  
  参与者：
  
       Component: 抽象构件。是定义一个对象接口，可以给这些对象动态地添加职责。

       ConcreteComponent:具体构件。是定义了一个具体的对象，也可以给这个对象添加一些职责。

       Decorator: 抽象装饰类。是装饰抽象类，继承了Component,从外类来扩展Component类的功能，但对于Component来说，是无需知道Decorator存在的。

       ConcreteDecorator:具体装饰类，起到给Component添加职责的功能。
       
## 5、外观模式(Facade)
   我们都知道类与类之间的耦合越低，那么可复用性就越好，如果两个类不必彼此通信，那么就不要让这两个类发生直接的相互关系，如果需要调用里面的方法，可以通过第三者来转发调用。
   外观模式非常好的诠释了这段话。**外观模式提供了一个统一的接口，用来访问子系统中的一群接口**。它让一个应用程序中子系统间的相互依赖关系减少到了最少，
   它给子系统提供了一个简单、单一的屏障，客户通过这个屏障来与子系统进行通信。

   通过使用外观模式，使得客户对子系统的引用变得简单了，实现了客户与子系统之间的松耦合。但是它违背了“开闭原则”，因为增加新的子系统可能需要修改外观类或客户端的源代码。
   
   ![](https://images0.cnblogs.com/blog/381060/201310/08191405-52d7986f49484723803d84fab3065082.png)
   
   参与者：
   
        Facade: 外观角色。知道哪些子系统类负责处理请求，将客户的请求代理给适合的子系统处理。

        SubSystem:子系统角色。实现子系统功能，处理Facade对象发来的请求。
        
## 6、享元模式(Flyweight)
   在一个系统中对象会使得内存占用过多，特别是那些大量重复的对象，这就是对系统资源的极大浪费。**享元模式对对象的重用提供了一种解决方案，它使用共享技术对相同或者相似对象实现重用。**

   享元模式就是运行共享技术有效地支持大量细粒度对象的复用。系统使用少量对象,而且这些都比较相似，状态变化小，可以实现对象的多次复用。这里有一点要注意：**享元模式要求能够共享的对象必须是细粒度对象**。

   享元模式通过共享技术使得系统中的对象个数大大减少了，同时享元模式使用了内部状态和外部状态，同时外部状态相对独立，不会影响到内部状态，所以享元模式能够使得享元对象在不同的环境下被共享。
   同时正是分为了内部状态和外部状态，享元模式会使得系统变得更加复杂，同时也会导致读取外部状态所消耗的时间过长。
    
   ![](https://images0.cnblogs.com/blog/381060/201310/08191406-1487fd3e50e847e4b090ad5993786f6d.png)
   
   参与者：
   
        Flyweight: 抽象享元类。所有具体享元类的超类或者接口，通过这个接口，Flyweight可以接受并作用于外部专题。
        ConcreteFlyweight: 具体享元类。指定内部状态，为内部状态增加存储空间。
        UnsharedConcreteFlyweight: 非共享具体享元类。指出那些不需要共享的Flyweight子类。
        FlyweightFactory: 享元工厂类。用来创建并管理Flyweight对象，它主要用来确保合理地共享Flyweight，当用户请求一个Flyweight时，FlyweightFactory就会提供一个已经创建的Flyweight对象或者新建一个（如果不存在）。
                 
## 7、代理模式(Proxy)
   **代理模式就是给一个对象提供一个代理，并由代理对象控制对原对象的引用**。它使得客户不能直接与真正的目标对象通信。**代理对象是目标对象的代表**，其他需要与这个目标对象打交道的操作都是和这个代理对象在交涉。
  
   代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了的作用和保护了目标对象的，同时也在一定程度上面减少了系统的耦合度。
   
   ![](https://images0.cnblogs.com/blog/381060/201310/08191407-3ebd72596df9459888d74f447b3c99c7.png)
   
   参与者：
   
        Subject: 抽象角色。声明真实对象和代理对象的共同接口。

        Proxy: 代理角色。代理对象与真实对象实现相同的接口，所以它能够在任何时刻都能够代理真实对象。代理角色内部包含有对真实对象的引用，所以她可以操作真实对象，同时也可以附加其他的操作，相当于对真实对象进行封装。

        RealSubject: 真实角色。它代表着真实对象，是我们最终要引用的对象。
        
        
        
        
   