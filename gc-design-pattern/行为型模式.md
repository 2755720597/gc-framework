## 行为型模式
   行为型模式主要是**用于描述类或者对象是怎样交互和怎样分配职责的**。它涉及到算法和对象间的职责分配，不仅描述对象或者类的模式，还描述了他们之间的通信方式，
   它将你的注意力从控制流转移到了对象间的关系上来。**行为型类模式采用继承机制在类间分派行为**，而行为型对象模式使用对象复合而不是继承。
   它主要包括如何11中设计模式：职责链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式。
   
## 1、职责链模式(Chain of Responsibility)
   职责链模式**描述的请求如何沿着对象所组成的链来传递的**。**它将对象组成一条链，发送者将请求发给链的第一个接收者，并且沿着这条链传递，直到有一个对象来处理它或者直到最后也没有对象处理而留在链末尾端。**
  
   避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止，这就是职责链模式。
   在职责链模式中，使得每一个对象都有可能来处理请求，从而实现了请求的发送者和接收者之间的解耦。同时职责链模式简化了对象的结构，它使得每个对象都只需要引用它的后继者即可，
   而不必了解整条链，这样既提高了系统的灵活性也使得增加新的请求处理类也比较方便。但是在职责链中我们不能保证所有的请求都能够被处理，而且不利于观察运行时特征。
   
   ![](https://images0.cnblogs.com/blog/381060/201310/08191408-238b750a1b7549e6b009d0bf622e79f1.png)
   
   参与者：
   
    Handler: 抽象处理者。定义了一个处理请求的方法。所有的处理者都必须实现该抽象类。
    ConcreteHandler: 具体处理者。处理它所负责的请求，同时也可以访问它的后继者。如果它能够处理该请求则处理，否则将请求传递到它的后继者。
    Client: 客户类。
    
 ![](https://www.runoob.com/wp-content/uploads/2014/08/2021-chain-of-responsibility.svg) 
  
## 2、命令模式(Command)
  有些时候我们想某个对象发送一个请求，但是我们并不知道该请求的具体接收者是谁，具体的处理过程是如何的，我们只知道在程序运行中指定具体的请求接收者即可，对于这样将请求封装成对象的我们称之为命令模式。
  所以**命令模式将请求封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。同时命令模式支持可撤销的操作。**
  
  命令模式可以将请求的发送者和接收者之间实现完全的解耦，发送者和接收者之间没有直接的联系，发送者只需要知道如何发送请求命令即可，其余的可以一概不管，
  甚至命令是否成功都无需关心。同时我们可以非常方便的增加新的命令，但是可能就是因为方便和对请求的封装就会导致系统中会存在过多的具体命令类。
  
  ![](https://images0.cnblogs.com/blog/381060/201310/08191409-4ed9525a3ba04720835c34c2f324fde4.png)
  
  参与者：
  
       Command: 抽象命令类。用来声明执行操作的接口。

       ConcreteCommand: 具体命令类。将一个接收者对象绑定于一个动作，调用接收者相应的操作，以实现Excute。

       Invoker: 调用者。要求该命令执行这个请求。

       Receiver: 接收者。知道如何实施与执行一个请求相关的操作，任何类都有可能成为一个接收者。

       Client:客户类。
       
       
## 3、解释器模式(Interpreter)
 所谓**解释器模式就是定义语言的文法，并且建立一个解释器来解释该语言中的句子**。解释器模式描述了如何构成一个简单的语言解释器，主要应用在使用面向对象语言开发的编译器中。
 它描述了如何为简单的语言定义一个文法，如何在该语言中表示一个句子，以及如何解释这些句子。
 
 ![](https://images0.cnblogs.com/blog/381060/201310/08191410-5cc92b75b3d843d7b2396eda23a54972.png)
 
 参与者：
 
      AbstractExpression: 抽象表达式。声明一个抽象的解释操作，该接口为抽象语法树中所有的节点共享。

      TerminalExpression: 终结符表达式。实现与文法中的终结符相关的解释操作。实现抽象表达式中所要求的方法。文法中每一个终结符都有一个具体的终结表达式与之相对应。

      NonterminalExpression: 非终结符表达式。为文法中的非终结符相关的解释操作。

      Context: 环境类。包含解释器之外的一些全局信息。

      Client: 客户类。
      
## 4、迭代器模式(Iterator)
   对于迭代在编程过程中我们经常用到，能够游走于聚合内的每一个元素，同时还可以提供多种不同的遍历方式，这就是迭代器模式的设计动机。在我们实际的开发过程中，
   我们可能会需要根据不同的需求以不同的方式来遍历整个对象，但是我们又不希望在聚合对象的抽象接口中充斥着各种不同的遍历操作，
   于是我们就希望有某个东西能够以多种不同的方式来遍历一个聚合对象，这时迭代器模式出现了。
  
   何为迭代器模式？所谓**迭代器模式就是提供一种方法顺序访问一个聚合对象中的各个元素，而不是暴露其内部的表示**。**迭代器模式是将迭代元素的责任交给迭代器，而不是聚合对象**，
   我们甚至在不需要知道该聚合对象的内部结构就可以实现该聚合对象的迭代。

   通过迭代器模式，使得聚合对象的结构更加简单，它不需要关注它元素的遍历，只需要专注它应该专注的事情，这样就更加符合单一职责原则了。
   
   ![](https://images0.cnblogs.com/blog/381060/201310/08191411-cc21bb883dd44c5da6f3ed220c09a33e.png)
   
  参与者：

     Iterator: 抽象迭代器：所有迭代器都需要实现的接口，提供了游走聚合对象元素之间的方法。

     ConcreteIterator: 具体迭代器。利用这个具体的迭代器能够对具体的聚合对象进行遍历。每一个聚合对象都应该对应一个具体的迭代器。

     Aggregate: 抽象聚合类。

     ConcreteAggregate: 具体聚合类。实现creatorIterator()方法，返回该聚合对象的迭代器。
     
## 5、中介者模式(Mediator)
   租房各位都有过的经历吧！在这个过程中中介结构扮演着很重要的角色，它在这里起到一个中间者的作用，给我们和房主互相传递信息。在外面软件的世界里同样需要这样一个中间者。
   在我们的系统中有时候会存在着对象与对象之间存在着很强、复杂的关联关系，如果让他们之间有直接的联系的话，必定会导致整个系统变得非常复杂，而且可扩展性很差！
   在前面我们就知道如果两个类之间没有不必彼此通信，我们就不应该让他们有直接的关联关系，如果实在是需要通信的话，我们可以通过第三者来转发他们的请求。同样，
   这里我们利用中介者来解决这个问题。
  
   所谓**中介者模式就是用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互**。
   在中介者模式中，中介对象用来封装对象之间的关系，各个对象可以不需要知道具体的信息通过中介者对象就可以实现相互通信。它减少了对象之间的互相关系，提供了系统可复用性，
   简化了系统的结构。

   在中介者模式中，各个对象不需要互相知道了解，他们只需要知道中介者对象即可，但是中介者对象就必须要知道所有的对象和他们之间的关联关系，
   正是因为这样就导致了中介者对象的结构过于复杂，承担了过多的职责，同时它也是整个系统的核心所在，它有问题将会导致整个系统的问题。
   所以如果在系统的设计过程中如果出现“多对多”的复杂关系群时，千万别急着使用中介者模式，而是要仔细思考是不是您设计的系统存在问题。
   
   ![](https://images0.cnblogs.com/blog/381060/201310/08191412-833ff9db6c2042359535a1105be7a95d.png)
   
   参与者：
   
    Mediator: 抽象中介者。定义了同事对象到中介者对象之间的接口。

    ConcreteMediator: 具体中介者。实现抽象中介者的方法，它需要知道所有的具体同事类，同时需要从具体的同事类那里接收信息，并且向具体的同事类发送信息。

    Colleague: 抽象同事类。

    ConcreteColleague: 具体同事类。每个具体同事类都只需要知道自己的行为即可，但是他们都需要认识中介者。
    
## 6、备忘录模式(Memento)
   后悔药人人都想要，但是事实却是残酷的，根本就没有后悔药可买，但是也不仅如此，在软件的世界里就有后悔药！备忘录模式就是一种后悔药，它给我们的软件提供后悔药的机制，
   通过它可以使系统恢复到某一特定的历史状态。
  
   所谓**备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态**。它实现了对信息的封装，
   使得客户不需要关心状态保存的细节。保存就要消耗资源，所以备忘录模式的**缺点就在于消耗资源**。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。
   
   ![](https://images0.cnblogs.com/blog/381060/201310/08191413-f5cab33db5a04d9a8c1e92438d105737.jpg)
   
   参与者：
   
    Originator: 原发器。负责创建一个备忘录，用以记录当前对象的内部状态，通过也可以使用它来利用备忘录恢复内部状态。同时原发器还可以根据需要决定Memento存储Originator的那些内部状态。

    Memento: 备忘录。用于存储Originator的内部状态，并且可以防止Originator以外的对象访问Memento。在备忘录Memento中有两个接口，其中Caretaker只能看到备忘录中的窄接口，它只能将备忘录传递给其他对象。Originator可以看到宽接口，允许它访问返回到先前状态的所有数据。

    Caretaker: 负责人。负责保存好备忘录，不能对备忘录的内容进行操作和访问，只能够将备忘录传递给其他对象。
    
## 7、观察者模式(Observer)
   何谓观察者模式？**观察者模式定义了对象之间的一对多依赖关系，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并且自动更新。**
  
   在这里，发生改变的对象称之为**观察目标**，而被通知的对象称之为**观察者**。一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，
   所以么可以根据需要增加和删除观察者，使得系统更易于扩展。

   所以观察者提供了一种对象设计，让主题和观察者之间以松耦合的方式结合。
   
   ![](https://images0.cnblogs.com/blog/381060/201310/08191414-3e73be5099d34cfd8a5e63a38b9f9f0e.png)
   
   参与者：
   
     Subject：目标。他把所有对观察者对戏的引用保存在一个聚集里，每一个主题都可以有多个观察者。

     Observer：观察者。为所有的具体观察者定义一个接口，在得到主题的通知时能够及时的更新自己。

     ConcreteSubject：具体主题。将有关状态存入具体观察者对象。在具体主题发生改变时，给所有的观察者发出通知。

     ConcreteObserver：具体观察者。实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题状态相协调。
   
## 8、状态模式(State)
  在很多情况下我们对象的行为依赖于它的一个或者多个变化的属性，这些可变的属性我们称之为**状态**，也就是说**行为依赖状态**，即当该对象因为在外部的互动而导致他的状态发生变化，
  从而它的行为也会做出相应的变化。对于这种情况，我们是不能用行为来控制状态的变化，而应该站在状态的角度来思考行为，即是什么状态就要做出什么样的行为。这个就是状态模式。
  
  **所以状态模式就是允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。**

  在状态模式中我们可以减少大块的if…else语句，它是允许态转换逻辑与状态对象合成一体，但是减少if…else语句的代价就是会换来大量的类，
  所以状态模式势必会增加系统中类或者对象的个数。

  同时状态模式是将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。但是这样就会导致系统的结构和实现都会比较复杂，
  如果使用不当就会导致程序的结构和代码混乱，不利于维护。
  
  ![](https://images0.cnblogs.com/blog/381060/201310/08191415-249d21e48e8d48d1ba2485b5b16575b9.png)
  
   参与者：
  
    Context：环境类。可以包括一些内部状态。
    State： 抽象状态类。State定义了一个所有具体状态的共同接口，任何状态都实现这个相同的接口，这样一来，状态之间就可以互相转换了。
    ConcreteState：具体状态类。具体状态类，用于处理来自Context的请求，每一个ConcreteState都提供了它对自己请求的实现，所以，当Context改变状态时行为也会跟着改变。
## 9、策略模式(Strategy)
   我们知道一件事可能会有很多种方式来实现它，但是其中总有一种最高效的方式，在软件开发的世界里面同样如此，我们也有很多中方法来实现一个功能，
   但是我们需要一种简单、高效的方式来实现它，使得系统能够非常灵活，这就是策略模式。
  
   **所以策略模式就是定义了算法族，分别封装起来，让他们之前可以互相转换，此模式然该算法的变化独立于使用算法的客户。**

   在策略模式中它将这些解决问题的方法定义成一个算法群，每一个方法都对应着一个具体的算法，这里的一个算法我就称之为一个策略。虽然策略模式定义了算法，
   但是它并不提供算法的选择，即什么算法对于什么问题最合适这是策略模式所不关心的，所以对于策略的选择还是要客户端来做。
   客户必须要清楚的知道每个算法之间的区别和在什么时候什么地方使用什么策略是最合适的，这样就增加客户端的负担。

   同时策略模式也非常完美的符合了“开闭原则”，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。
   但是一个策略对应一个类将会是系统产生很多的策略类。
   
   ![](https://images0.cnblogs.com/blog/381060/201310/08191416-280154a0c6674f6596e6a9e5fa6cd69e.png)
   
   参与者：
   
        Context: 环境类。维护一个Strategy对象的引用，用一个ConcreteStrategy来配置，可定义一个接口来让Strategy访问它的数据。
        Strategy: 抽象策略类。定义所有支持算法的公共接口。Context使用这个接口来调用某个Concretestrategy定义的算法。
        ConcreteStrategy: 具体策略类。封装了具体的算法实现。
    
## 10、模板方法模式(Template Method)
  有些时候我们做某几件事情的步骤都差不多，仅有那么一小点的不同，在软件开发的世界里同样如此，如果我们都将这些步骤都一一做的话，费时费力不讨好。
  所以我们可以将这些步骤分解、封装起来，然后利用继承的方式来继承即可，当然不同的可以自己重写实现嘛！这就是模板方法模式提供的解决方案。
  
  **所谓模板方法模式就是在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。**

  模板方法模式就是基于继承的代码复用技术的。在模板方法模式中，我们可以将相同部分的代码放在父类中，而将不同的代码放入不同的子类中。也就是说我们需要声明一个抽象的父类，
  将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法让子类来实现剩余的逻辑，不同的子类可以以不同的方式来实现这些逻辑。
  所以模板方法的模板其实就是一个普通的方法，只不过这个方法是将算法实现的步骤封装起来的。
  
  ![](https://images0.cnblogs.com/blog/381060/201310/08191417-b2282b6c648649f99f346e99e23a0a49.png)
  
  参与者：
  
       AbstractClass: 抽象类。实现了一个模板，实现算法的基本骨架，具体子类将重定义primitiveOperation()方法以实现一个算法步骤。

       ConcreteClass:  具体子类。实现primitiveOperation()方法以完成算法中与特定子类相关的步骤。
       
## 11、访问者模式(Visitor)
   访问者模式俗称23大设计模式中最难的一个。除了结构复杂外，理解也比较难。在我们软件开发中我们可能会对同一个对象有不同的处理，如果我们都做分别的处理，
   将会产生灾难性的错误。对于这种问题，访问者模式提供了比较好的解决方案。
  
   **访问者模式即表示一个作用于某对象结构中的各元素的操作，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。**

   访问者模式的**目的是封装一些施加于某种数据结构元素之上的操作**，一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。为不同类型的元素提供多种访问操作方式，
   且可以在不修改原有系统的情况下增加新的操作方式。同时我们还需要明确一点那就是访问者模式是适用于那些数据结构比较稳定的，因为他是将数据的操作与数据结构进行分离了，
   如果某个系统的数据结构相对稳定，但是操作算法易于变化的话，就比较适用适用访问者模式，因为访问者模式使得算法操作的增加变得比较简单了。
   
   ![](https://images0.cnblogs.com/blog/381060/201310/08191417-a57373321c394a8391aaca5c3cabd27e.jpg)
   
    参与者：
   
        Vistor: 抽象访问者。为该对象结构中的ConcreteElement的每一个类声明的一个操作。
        ConcreteVisitor: 具体访问者。实现Visitor申明的每一个操作，每一个操作实现算法的一部分。
        Element: 抽象元素。定义一个Accept操作，它以一个访问者为参数。
        ConcreteElement: 具体元素 。实现Accept操作。
        ObjectStructure: 对象结构。能够枚举它的元素，可以提供一个高层的接口来允许访问者访问它的元素。
        

    
    
        
    
        
        
        
        
            
   
        
   